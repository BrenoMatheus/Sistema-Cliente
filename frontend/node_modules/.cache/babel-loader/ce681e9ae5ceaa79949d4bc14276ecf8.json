{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\", \"clearable\", \"onClear\", \"disabled\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useTheme } from '@mui/material/styles';\nimport { useValidation } from '../useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString, getSectionOrder } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nimport { getActiveElement } from '../../utils/utils';\nexport const useField = params => {\n  const utils = useUtils();\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionsValueBoundaries,\n    placeholder,\n    timezone\n  } = useFieldState(params);\n\n  const {\n    inputRef: inputRefProp,\n    internalProps,\n    internalProps: {\n      readOnly = false,\n      unstableFieldRef,\n      minutesStep\n    },\n    forwardedProps: {\n      onClick,\n      onKeyDown,\n      onFocus,\n      onBlur,\n      onMouseUp,\n      onPaste,\n      error,\n      clearable,\n      onClear,\n      disabled\n    },\n    fieldValueManager,\n    valueManager,\n    validator\n  } = params,\n        otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr,\n    timezone\n  });\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const sectionOrder = React.useMemo(() => getSectionOrder(state.sections, isRTL), [state.sections, isRTL]);\n\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    let nextSectionIndex;\n\n    if (browserStartIndex <= state.sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= state.sections[state.sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n\n  const handleInputClick = useEventCallback(function (event) {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    onClick == null || onClick(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null || onMouseUp(event); // Without this, the browser will remove the selected when clicking inside an already-selected section.\n\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback(function () {\n    onFocus == null || onFocus(...arguments); // The ref is guaranteed to be resolved at this point.\n\n    const input = inputRef.current;\n    window.clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n\n      if (selectedSectionIndexes != null || readOnly) {\n        return;\n      }\n\n      if ( // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback(function () {\n    onBlur == null || onBlur(...arguments);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null || onPaste(event);\n\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n\n    const pastedValue = event.clipboardData.getData('text');\n\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        }); // prevent default to avoid the input change handler being called\n\n        event.preventDefault();\n        return;\n      }\n\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n\n    const targetValue = event.target.value;\n\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n\n    const eventData = event.nativeEvent.data; // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr); // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n\n    if (selectedSectionIndexes == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n\n    let keyPressed;\n\n    if (selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1 && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections, isRTL));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      } // The active section being selected, the browser has replaced its value with the key pressed by the user.\n\n\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      } else {\n        resetCharacterQuery();\n        clearActiveSection();\n      }\n\n      return;\n    }\n\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null || onKeyDown(event); // eslint-disable-next-line default-case\n\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n      // Move selection to next section\n\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n\n          break;\n        }\n      // Move selection to previous section\n\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n\n          break;\n        }\n      // Reset the value of the selected section\n\n      case event.key === 'Delete':\n        {\n          event.preventDefault();\n\n          if (readOnly) {\n            break;\n          }\n\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n\n          resetCharacterQuery();\n          break;\n        }\n      // Increment / decrement the selected section value\n\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, timezone, activeSection, event.key, sectionsValueBoundaries, activeDateManager.date, {\n            minutesStep\n          });\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (!inputRef.current) {\n      return;\n    }\n\n    if (selectedSectionIndexes == null) {\n      if (inputRef.current.scrollLeft) {\n        // Ensure that input content is not marked as selected.\n        // setting selection range to 0 causes issues in Safari.\n        // https://bugs.webkit.org/show_bug.cgi?id=224425\n        inputRef.current.scrollLeft = 0;\n      }\n\n      return;\n    }\n\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n      const currentScrollTop = inputRef.current.scrollTop; // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n\n      if (inputRef.current === getActiveElement(document)) {\n        inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n      } // Even reading this variable seems to do the trick, but also setting it just to make use of it\n\n\n      inputRef.current.scrollTop = currentScrollTop;\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value,\n    timezone\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n\n    return valueManager.hasError(validationError);\n  }, [valueManager, validationError, error]);\n  React.useEffect(() => {\n    if (!inputError && !selectedSectionIndexes) {\n      resetCharacterQuery();\n    }\n  }, [state.referenceValue, selectedSectionIndexes, inputError]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections, isRTL);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid, isRTL]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n\n    return 'numeric';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const areAllSectionsEmpty = valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  React.useImperativeHandle(unstableFieldRef, () => ({\n    getSections: () => state.sections,\n    getActiveSectionIndex: () => {\n      var _selectionStart2, _selectionEnd;\n\n      const browserStartIndex = (_selectionStart2 = inputRef.current.selectionStart) != null ? _selectionStart2 : 0;\n      const browserEndIndex = (_selectionEnd = inputRef.current.selectionEnd) != null ? _selectionEnd : 0;\n\n      if (browserStartIndex === 0 && browserEndIndex === 0) {\n        return null;\n      }\n\n      const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    },\n    setSelectedSections: activeSectionIndex => setSelectedSections(activeSectionIndex)\n  }));\n  const handleClearValue = useEventCallback(function (event) {\n    var _inputRef$current;\n\n    event.preventDefault();\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    onClear == null || onClear(event, ...args);\n    clearValue();\n    inputRef == null || (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();\n    setSelectedSections(0);\n  });\n  return _extends({\n    placeholder,\n    autoComplete: 'off',\n    disabled: Boolean(disabled)\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    onClear: handleClearValue,\n    error: inputError,\n    ref: handleRef,\n    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)\n  });\n};","map":{"version":3,"sources":["/home/brenomatheus/Documentos/frontend/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.js"],"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","useEnhancedEffect","useEventCallback","useForkRef","useTheme","useValidation","useUtils","adjustSectionValue","isAndroid","cleanString","getSectionOrder","useFieldState","useFieldCharacterEditing","getActiveElement","useField","params","utils","state","selectedSectionIndexes","setSelectedSections","clearValue","clearActiveSection","updateSectionValue","updateValueFromValueStr","setTempAndroidValueStr","sectionsValueBoundaries","placeholder","timezone","inputRef","inputRefProp","internalProps","readOnly","unstableFieldRef","minutesStep","forwardedProps","onClick","onKeyDown","onFocus","onBlur","onMouseUp","onPaste","error","clearable","onClear","disabled","fieldValueManager","valueManager","validator","otherForwardedProps","applyCharacterEditing","resetCharacterQuery","sections","useRef","handleRef","focusTimeoutRef","undefined","theme","isRTL","direction","sectionOrder","useMemo","syncSelectionFromDOM","_selectionStart","browserStartIndex","current","selectionStart","nextSectionIndex","startInInput","length","endInInput","findIndex","section","startSeparator","sectionIndex","handleInputClick","event","isDefaultPrevented","args","handleInputMouseUp","preventDefault","handleInputFocus","input","window","clearTimeout","setTimeout","value","Number","selectionEnd","handleInputBlur","handleInputPaste","pastedValue","clipboardData","getData","startIndex","endIndex","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleInputChange","targetValue","target","eventData","nativeEvent","data","shouldUseEventData","valueStr","cleanValueStr","keyPressed","prevValueStr","getValueStrFromSections","startOfDiffIndex","endOfDiffIndex","i","hasDiffOutsideOfActiveSection","start","end","activeSectionEndRelativeToNewValue","endSeparator","slice","handleInputKeyDown","key","ctrlKey","metaKey","neighbors","rightIndex","leftIndex","includes","activeDateManager","getActiveDateManager","date","scrollLeft","firstSelectedSection","lastSelectedSection","shouldSelectBoundarySelectors","currentScrollTop","scrollTop","document","setSelectionRange","validationError","isSameError","defaultErrorState","inputError","hasError","useEffect","referenceValue","activeElement","tempValueStrAndroid","_state$tempValueStrAn","inputMode","inputHasFocus","areAllSectionsEmpty","areValuesEqual","emptyValue","shouldShowPlaceholder","useImperativeHandle","getSections","getActiveSectionIndex","_selectionStart2","_selectionEnd","browserEndIndex","activeSectionIndex","handleClearValue","_inputRef$current","focus","autoComplete","Boolean","onChange","ref"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onClick\", \"onKeyDown\", \"onFocus\", \"onBlur\", \"onMouseUp\", \"onPaste\", \"error\", \"clearable\", \"onClear\", \"disabled\"];\nimport * as React from 'react';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useForkRef from '@mui/utils/useForkRef';\nimport { useTheme } from '@mui/material/styles';\nimport { useValidation } from '../useValidation';\nimport { useUtils } from '../useUtils';\nimport { adjustSectionValue, isAndroid, cleanString, getSectionOrder } from './useField.utils';\nimport { useFieldState } from './useFieldState';\nimport { useFieldCharacterEditing } from './useFieldCharacterEditing';\nimport { getActiveElement } from '../../utils/utils';\nexport const useField = params => {\n  const utils = useUtils();\n  const {\n    state,\n    selectedSectionIndexes,\n    setSelectedSections,\n    clearValue,\n    clearActiveSection,\n    updateSectionValue,\n    updateValueFromValueStr,\n    setTempAndroidValueStr,\n    sectionsValueBoundaries,\n    placeholder,\n    timezone\n  } = useFieldState(params);\n  const {\n      inputRef: inputRefProp,\n      internalProps,\n      internalProps: {\n        readOnly = false,\n        unstableFieldRef,\n        minutesStep\n      },\n      forwardedProps: {\n        onClick,\n        onKeyDown,\n        onFocus,\n        onBlur,\n        onMouseUp,\n        onPaste,\n        error,\n        clearable,\n        onClear,\n        disabled\n      },\n      fieldValueManager,\n      valueManager,\n      validator\n    } = params,\n    otherForwardedProps = _objectWithoutPropertiesLoose(params.forwardedProps, _excluded);\n  const {\n    applyCharacterEditing,\n    resetCharacterQuery\n  } = useFieldCharacterEditing({\n    sections: state.sections,\n    updateSectionValue,\n    sectionsValueBoundaries,\n    setTempAndroidValueStr,\n    timezone\n  });\n  const inputRef = React.useRef(null);\n  const handleRef = useForkRef(inputRefProp, inputRef);\n  const focusTimeoutRef = React.useRef(undefined);\n  const theme = useTheme();\n  const isRTL = theme.direction === 'rtl';\n  const sectionOrder = React.useMemo(() => getSectionOrder(state.sections, isRTL), [state.sections, isRTL]);\n  const syncSelectionFromDOM = () => {\n    var _selectionStart;\n    if (readOnly) {\n      setSelectedSections(null);\n      return;\n    }\n    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;\n    let nextSectionIndex;\n    if (browserStartIndex <= state.sections[0].startInInput) {\n      // Special case if browser index is in invisible characters at the beginning\n      nextSectionIndex = 1;\n    } else if (browserStartIndex >= state.sections[state.sections.length - 1].endInInput) {\n      // If the click is after the last character of the input, then we want to select the 1st section.\n      nextSectionIndex = 1;\n    } else {\n      nextSectionIndex = state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n    }\n    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    setSelectedSections(sectionIndex);\n  };\n  const handleInputClick = useEventCallback((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleInputClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    onClick == null || onClick(event, ...args);\n    syncSelectionFromDOM();\n  });\n  const handleInputMouseUp = useEventCallback(event => {\n    onMouseUp == null || onMouseUp(event);\n\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const handleInputFocus = useEventCallback((...args) => {\n    onFocus == null || onFocus(...args);\n    // The ref is guaranteed to be resolved at this point.\n    const input = inputRef.current;\n    window.clearTimeout(focusTimeoutRef.current);\n    focusTimeoutRef.current = setTimeout(() => {\n      // The ref changed, the component got remounted, the focus event is no longer relevant.\n      if (!input || input !== inputRef.current) {\n        return;\n      }\n      if (selectedSectionIndexes != null || readOnly) {\n        return;\n      }\n      if (\n      // avoid selecting all sections when focusing empty field without value\n      input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length) {\n        setSelectedSections('all');\n      } else {\n        syncSelectionFromDOM();\n      }\n    });\n  });\n  const handleInputBlur = useEventCallback((...args) => {\n    onBlur == null || onBlur(...args);\n    setSelectedSections(null);\n  });\n  const handleInputPaste = useEventCallback(event => {\n    onPaste == null || onPaste(event);\n    if (readOnly) {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n      const digitsOnly = /^[0-9]+$/.test(pastedValue);\n      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n      const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n      if (isValidPastedValue) {\n        resetCharacterQuery();\n        updateSectionValue({\n          activeSection,\n          newSectionValue: pastedValue,\n          shouldGoToNextSection: true\n        });\n        // prevent default to avoid the input change handler being called\n        event.preventDefault();\n        return;\n      }\n      if (lettersOnly || digitsOnly) {\n        // The pasted value correspond to a single section but not the expected type\n        // skip the modification\n        event.preventDefault();\n        return;\n      }\n    }\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleInputChange = useEventCallback(event => {\n    if (readOnly) {\n      return;\n    }\n    const targetValue = event.target.value;\n    if (targetValue === '') {\n      resetCharacterQuery();\n      clearValue();\n      return;\n    }\n    const eventData = event.nativeEvent.data;\n    // Calling `.fill(04/11/2022)` in playwright will trigger a change event with the requested content to insert in `event.nativeEvent.data`\n    // usual changes have only the currently typed character in the `event.nativeEvent.data`\n    const shouldUseEventData = eventData && eventData.length > 1;\n    const valueStr = shouldUseEventData ? eventData : targetValue;\n    const cleanValueStr = cleanString(valueStr);\n\n    // If no section is selected or eventData should be used, we just try to parse the new value\n    // This line is mostly triggered by imperative code / application tests.\n    if (selectedSectionIndexes == null || shouldUseEventData) {\n      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);\n      return;\n    }\n    let keyPressed;\n    if (selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1 && cleanValueStr.length === 1) {\n      keyPressed = cleanValueStr;\n    } else {\n      const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections, isRTL));\n      let startOfDiffIndex = -1;\n      let endOfDiffIndex = -1;\n      for (let i = 0; i < prevValueStr.length; i += 1) {\n        if (startOfDiffIndex === -1 && prevValueStr[i] !== cleanValueStr[i]) {\n          startOfDiffIndex = i;\n        }\n        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i - 1] !== cleanValueStr[cleanValueStr.length - i - 1]) {\n          endOfDiffIndex = i;\n        }\n      }\n      const activeSection = state.sections[selectedSectionIndexes.startIndex];\n      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;\n      if (hasDiffOutsideOfActiveSection) {\n        // TODO: Support if the new date is valid\n        return;\n      }\n\n      // The active section being selected, the browser has replaced its value with the key pressed by the user.\n      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || '').length;\n      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || '').length, activeSectionEndRelativeToNewValue);\n    }\n    if (keyPressed.length === 0) {\n      if (isAndroid()) {\n        setTempAndroidValueStr(valueStr);\n      } else {\n        resetCharacterQuery();\n        clearActiveSection();\n      }\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex: selectedSectionIndexes.startIndex\n    });\n  });\n  const handleInputKeyDown = useEventCallback(event => {\n    onKeyDown == null || onKeyDown(event);\n\n    // eslint-disable-next-line default-case\n    switch (true) {\n      // Select all\n      case event.key === 'a' && (event.ctrlKey || event.metaKey):\n        {\n          // prevent default to make sure that the next line \"select all\" while updating\n          // the internal state at the same time.\n          event.preventDefault();\n          setSelectedSections('all');\n          break;\n        }\n\n      // Move selection to next section\n      case event.key === 'ArrowRight':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.startIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.endIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Move selection to previous section\n      case event.key === 'ArrowLeft':\n        {\n          event.preventDefault();\n          if (selectedSectionIndexes == null) {\n            setSelectedSections(sectionOrder.endIndex);\n          } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {\n            setSelectedSections(selectedSectionIndexes.startIndex);\n          } else {\n            const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;\n            if (nextSectionIndex !== null) {\n              setSelectedSections(nextSectionIndex);\n            }\n          }\n          break;\n        }\n\n      // Reset the value of the selected section\n      case event.key === 'Delete':\n        {\n          event.preventDefault();\n          if (readOnly) {\n            break;\n          }\n          if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {\n            clearValue();\n          } else {\n            clearActiveSection();\n          }\n          resetCharacterQuery();\n          break;\n        }\n\n      // Increment / decrement the selected section value\n      case ['ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'].includes(event.key):\n        {\n          event.preventDefault();\n          if (readOnly || selectedSectionIndexes == null) {\n            break;\n          }\n          const activeSection = state.sections[selectedSectionIndexes.startIndex];\n          const activeDateManager = fieldValueManager.getActiveDateManager(utils, state, activeSection);\n          const newSectionValue = adjustSectionValue(utils, timezone, activeSection, event.key, sectionsValueBoundaries, activeDateManager.date, {\n            minutesStep\n          });\n          updateSectionValue({\n            activeSection,\n            newSectionValue,\n            shouldGoToNextSection: false\n          });\n          break;\n        }\n    }\n  });\n  useEnhancedEffect(() => {\n    if (!inputRef.current) {\n      return;\n    }\n    if (selectedSectionIndexes == null) {\n      if (inputRef.current.scrollLeft) {\n        // Ensure that input content is not marked as selected.\n        // setting selection range to 0 causes issues in Safari.\n        // https://bugs.webkit.org/show_bug.cgi?id=224425\n        inputRef.current.scrollLeft = 0;\n      }\n      return;\n    }\n    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];\n    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];\n    let selectionStart = firstSelectedSection.startInInput;\n    let selectionEnd = lastSelectedSection.endInInput;\n    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {\n      selectionStart -= firstSelectedSection.startSeparator.length;\n      selectionEnd += lastSelectedSection.endSeparator.length;\n    }\n    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {\n      // Fix scroll jumping on iOS browser: https://github.com/mui/mui-x/issues/8321\n      const currentScrollTop = inputRef.current.scrollTop;\n      // On multi input range pickers we want to update selection range only for the active input\n      // This helps to avoid the focus jumping on Safari https://github.com/mui/mui-x/issues/9003\n      // because WebKit implements the `setSelectionRange` based on the spec: https://bugs.webkit.org/show_bug.cgi?id=224425\n      if (inputRef.current === getActiveElement(document)) {\n        inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n      }\n      // Even reading this variable seems to do the trick, but also setting it just to make use of it\n      inputRef.current.scrollTop = currentScrollTop;\n    }\n  });\n  const validationError = useValidation(_extends({}, internalProps, {\n    value: state.value,\n    timezone\n  }), validator, valueManager.isSameError, valueManager.defaultErrorState);\n  const inputError = React.useMemo(() => {\n    // only override when `error` is undefined.\n    // in case of multi input fields, the `error` value is provided externally and will always be defined.\n    if (error !== undefined) {\n      return error;\n    }\n    return valueManager.hasError(validationError);\n  }, [valueManager, validationError, error]);\n  React.useEffect(() => {\n    if (!inputError && !selectedSectionIndexes) {\n      resetCharacterQuery();\n    }\n  }, [state.referenceValue, selectedSectionIndexes, inputError]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  React.useEffect(() => {\n    // Select the right section when focused on mount (`autoFocus = true` on the input)\n    if (inputRef.current && inputRef.current === document.activeElement) {\n      setSelectedSections('all');\n    }\n    return () => window.clearTimeout(focusTimeoutRef.current);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  // If `state.tempValueStrAndroid` is still defined when running `useEffect`,\n  // Then `onChange` has only been called once, which means the user pressed `Backspace` to reset the section.\n  // This causes a small flickering on Android,\n  // But we can't use `useEnhancedEffect` which is always called before the second `onChange` call and then would cause false positives.\n  React.useEffect(() => {\n    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {\n      resetCharacterQuery();\n      clearActiveSection();\n    }\n  }, [state.tempValueStrAndroid]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const valueStr = React.useMemo(() => {\n    var _state$tempValueStrAn;\n    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections, isRTL);\n  }, [state.sections, fieldValueManager, state.tempValueStrAndroid, isRTL]);\n  const inputMode = React.useMemo(() => {\n    if (selectedSectionIndexes == null) {\n      return 'text';\n    }\n    if (state.sections[selectedSectionIndexes.startIndex].contentType === 'letter') {\n      return 'text';\n    }\n    return 'numeric';\n  }, [selectedSectionIndexes, state.sections]);\n  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);\n  const areAllSectionsEmpty = valueManager.areValuesEqual(utils, state.value, valueManager.emptyValue);\n  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;\n  React.useImperativeHandle(unstableFieldRef, () => ({\n    getSections: () => state.sections,\n    getActiveSectionIndex: () => {\n      var _selectionStart2, _selectionEnd;\n      const browserStartIndex = (_selectionStart2 = inputRef.current.selectionStart) != null ? _selectionStart2 : 0;\n      const browserEndIndex = (_selectionEnd = inputRef.current.selectionEnd) != null ? _selectionEnd : 0;\n      if (browserStartIndex === 0 && browserEndIndex === 0) {\n        return null;\n      }\n      const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 // Special case if browser index is in invisible characters at the beginning.\n      : state.sections.findIndex(section => section.startInInput - section.startSeparator.length > browserStartIndex);\n      return nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;\n    },\n    setSelectedSections: activeSectionIndex => setSelectedSections(activeSectionIndex)\n  }));\n  const handleClearValue = useEventCallback((event, ...args) => {\n    var _inputRef$current;\n    event.preventDefault();\n    onClear == null || onClear(event, ...args);\n    clearValue();\n    inputRef == null || (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();\n    setSelectedSections(0);\n  });\n  return _extends({\n    placeholder,\n    autoComplete: 'off',\n    disabled: Boolean(disabled)\n  }, otherForwardedProps, {\n    value: shouldShowPlaceholder ? '' : valueStr,\n    inputMode,\n    readOnly,\n    onClick: handleInputClick,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onPaste: handleInputPaste,\n    onChange: handleInputChange,\n    onKeyDown: handleInputKeyDown,\n    onMouseUp: handleInputMouseUp,\n    onClear: handleClearValue,\n    error: inputError,\n    ref: handleRef,\n    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)\n  });\n};"]},"metadata":{},"sourceType":"module"}