{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getMonthsInYear } from '../../utils/date-utils';\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\n\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n\n    case 'ArrowDown':\n      return -1;\n\n    case 'PageUp':\n      return 5;\n\n    case 'PageDown':\n      return -5;\n\n    default:\n      return 0;\n  }\n};\n\nexport const getDaysInWeekStr = (utils, timezone, format) => {\n  const elements = [];\n  const now = utils.dateWithTimezone(undefined, timezone);\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.dateWithTimezone(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n\n    case 'meridiem':\n      {\n        const now = utils.dateWithTimezone(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const cleanLeadingZeros = (utils, valueStr, size) => {\n  let cleanValueStr = valueStr; // Remove the leading zeros\n\n  cleanValueStr = Number(cleanValueStr).toString(); // Add enough leading zeros to fill the section\n\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n\n  return cleanValueStr;\n};\nexport const cleanDigitSectionValue = (utils, timezone, value, sectionBoundaries, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  } // queryValue without leading `0` (`01` => `1`)\n\n\n  const valueStr = value.toString();\n\n  if (section.hasLeadingZerosInInput) {\n    return cleanLeadingZeros(utils, valueStr, section.maxLength);\n  }\n\n  return valueStr;\n};\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n\n    const getCleanValue = value => cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section);\n\n    const step = section.type === 'minutes' && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;\n    const currentSectionValue = parseInt(section.value, 10);\n    let newSectionValueNumber = currentSectionValue + delta * step;\n\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.dateWithTimezone(undefined, timezone), section.format);\n      }\n\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    return getCleanValue(newSectionValueNumber);\n  };\n\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n\n    if (options.length === 0) {\n      return section.value;\n    }\n\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n\n      return options[options.length - 1];\n    }\n\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n\n  return adjustLetterSection();\n};\nexport const getSectionVisibleValue = (section, target) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(value).toString();\n  } // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n\n\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, isRTL) => {\n  let position = 0;\n  let positionInInput = isRTL ? 1 : 0;\n  const newSections = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length; // The ...InInput values consider the unicode characters but do include them in their indexes\n\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength; // Move position to the end of string associated to the current section\n\n    positionInInput += sectionLengthInInput;\n  }\n\n  return newSections;\n};\n\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.dateWithTimezone(undefined, timezone), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\n\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\n\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.dateWithTimezone(undefined, timezone), format).length === 4;\n\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n\n  const now = utils.dateWithTimezone(undefined, timezone);\n\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null; // eslint-disable-next-line no-cond-assign\n\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n\n  return escapedParts;\n};\n\nexport const splitFormatIntoSections = (utils, timezone, localeText, format, date, formatDensity, shouldRespectLeadingZeros, isRTL) => {\n  let startSeparator = '';\n  const sections = [];\n  const now = utils.date();\n\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n    const isValidDate = date != null && utils.isValid(date);\n    let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n    let maxLength = null;\n\n    if (hasLeadingZerosInInput) {\n      if (hasLeadingZerosInFormat) {\n        maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n      } else {\n        if (sectionConfig.maxLength == null) {\n          throw new Error(`MUI: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\n        }\n\n        maxLength = sectionConfig.maxLength;\n\n        if (isValidDate) {\n          sectionValue = cleanLeadingZeros(utils, sectionValue, maxLength);\n        }\n      }\n    }\n\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      maxLength,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n      hasLeadingZeros: hasLeadingZerosInFormat,\n      hasLeadingZerosInFormat,\n      hasLeadingZerosInInput,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  }; // Expand the provided format\n\n\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component');\n    }\n  }\n\n  const expandedFormat = nextFormat; // Get start/end indexes of escaped sections\n\n  const escapedParts = getEscapedPartsFromFormat(utils, expandedFormat); // This RegExp test if the beginning of a string correspond to a supported token\n\n  const isTokenStartRegExp = new RegExp(`^(${Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length) // Sort to put longest word first\n  .join('|')})`, 'g') // used to get access to lastIndex state\n  ;\n  let currentTokenValue = '';\n\n  for (let i = 0; i < expandedFormat.length; i += 1) {\n    const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n    const char = expandedFormat[i];\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const potentialToken = `${currentTokenValue}${expandedFormat.slice(i)}`;\n    const regExpMatch = isTokenStartRegExp.test(potentialToken);\n\n    if (!isEscapedChar && char.match(/([A-Za-z]+)/) && regExpMatch) {\n      currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);\n      i += isTokenStartRegExp.lastIndex - 1;\n    } else {\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n\n      if (!isEscapeBoundary) {\n        commitToken(currentTokenValue);\n        currentTokenValue = '';\n\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n    }\n  }\n\n  commitToken(currentTokenValue);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n\n      return cleanedSeparator;\n    };\n\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\n\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input'));\n    }\n  }\n\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = (sections, isRTL) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n\n  if (!isRTL) {\n    return dateStr;\n  } // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n\n\n  return `\\u2066${dateStr}\\u2069`;\n};\nexport const getSectionsBoundaries = (utils, timezone) => {\n  const today = utils.dateWithTimezone(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: _ref => {\n      let {\n        format\n      } = _ref;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n      };\n    },\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: _ref2 => {\n      let {\n        currentDate\n      } = _ref2;\n      return {\n        minimum: 1,\n        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: _ref3 => {\n      let {\n        format,\n        contentType\n      } = _ref3;\n\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: _ref4 => {\n      let {\n        format\n      } = _ref4;\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\n\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n\n        return dateToTransferTo;\n      }\n\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\n\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8\n};\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => // cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n  }\n\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex( // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' ')) && // Special case where the spaces were not there in the initial input\n      section.endSeparator !== ' / ';\n    });\n\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};","map":{"version":3,"sources":["/home/brenomatheus/Documentos/frontend/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"],"names":["_extends","getMonthsInYear","getDateSectionConfigFromFormatToken","utils","formatToken","config","formatTokenMap","Error","join","type","contentType","maxLength","undefined","sectionType","getDeltaFromKeyCode","keyCode","getDaysInWeekStr","timezone","format","elements","now","dateWithTimezone","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","getLetterEditingOptions","month","startOfDay","endOfDay","date","cleanLeadingZeros","valueStr","size","cleanValueStr","Number","toString","length","cleanDigitSectionValue","value","sectionBoundaries","section","process","env","NODE_ENV","setDate","longestMonth","hasLeadingZerosInInput","adjustSectionValue","sectionsValueBoundaries","activeDate","stepsAttributes","delta","isStart","isEnd","shouldSetAbsolute","adjustDigitSection","currentDate","getCleanValue","step","minutesStep","currentSectionValue","parseInt","newSectionValueNumber","minimum","maximum","adjustLetterSection","options","currentOptionIndex","indexOf","newOptionIndex","getSectionVisibleValue","target","placeholder","hasLeadingZeros","hasLeadingZerosInFormat","shouldAddInvisibleSpace","includes","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","isRTL","position","positionInInput","newSections","i","renderedValue","sectionStr","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","endInInput","start","end","getSectionPlaceholder","localeText","sectionConfig","sectionFormat","fieldYearPlaceholder","digitAmount","fieldMonthPlaceholder","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","changeSectionValueFormat","currentFormat","newFormat","parse","isFourDigitYearFormat","doesSectionFormatHaveLeadingZeros","formatted0001","setYear","formatted2001","startOfYear","startOfMonth","setHours","setMinutes","setSeconds","getEscapedPartsFromFormat","escapedParts","startChar","endChar","escapedCharacters","regExp","RegExp","match","exec","index","lastIndex","splitFormatIntoSections","formatDensity","shouldRespectLeadingZeros","commitToken","token","isValidDate","isValid","sectionValue","modified","formatExpansionOverflow","prevFormat","nextFormat","expandFormat","expandedFormat","isTokenStartRegExp","Object","keys","sort","a","b","currentTokenValue","escapedPartOfCurrentChar","find","escapeIndex","char","isEscapedChar","potentialToken","slice","regExpMatch","test","isEscapeBoundary","cleanSeparator","separator","cleanedSeparator","getDateFromDateSections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForInputFromSections","formattedSections","dateValue","dateStr","getSectionsBoundaries","today","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","getMonth","day","daysInWeek","Math","min","max","hours","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","reliableSectionModificationOrder","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","mergedDate","isAndroid","navigator","userAgent","toLowerCase","getSectionOrder","neighbors","forEach","_","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","_section$endSeparator","rtlIndex"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getMonthsInYear } from '../../utils/date-utils';\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, timezone, format) => {\n  const elements = [];\n  const now = utils.dateWithTimezone(undefined, timezone);\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.dateWithTimezone(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.dateWithTimezone(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const cleanLeadingZeros = (utils, valueStr, size) => {\n  let cleanValueStr = valueStr;\n\n  // Remove the leading zeros\n  cleanValueStr = Number(cleanValueStr).toString();\n\n  // Add enough leading zeros to fill the section\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n  return cleanValueStr;\n};\nexport const cleanDigitSectionValue = (utils, timezone, value, sectionBoundaries, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  const valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    return cleanLeadingZeros(utils, valueStr, section.maxLength);\n  }\n  return valueStr;\n};\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section);\n    const step = section.type === 'minutes' && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;\n    const currentSectionValue = parseInt(section.value, 10);\n    let newSectionValueNumber = currentSectionValue + delta * step;\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.dateWithTimezone(undefined, timezone), section.format);\n      }\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nexport const getSectionVisibleValue = (section, target) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(value).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, isRTL) => {\n  let position = 0;\n  let positionInInput = isRTL ? 1 : 0;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, sectionFormat) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.dateWithTimezone(undefined, timezone), sectionFormat).length,\n          format: sectionFormat\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType,\n          format: sectionFormat\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder({\n          format: sectionFormat\n        });\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder({\n          format: sectionFormat\n        });\n      }\n    default:\n      {\n        return sectionFormat;\n      }\n  }\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.dateWithTimezone(undefined, timezone), format).length === 4;\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = utils.dateWithTimezone(undefined, timezone);\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nexport const splitFormatIntoSections = (utils, timezone, localeText, format, date, formatDensity, shouldRespectLeadingZeros, isRTL) => {\n  let startSeparator = '';\n  const sections = [];\n  const now = utils.date();\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n    const isValidDate = date != null && utils.isValid(date);\n    let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n    let maxLength = null;\n    if (hasLeadingZerosInInput) {\n      if (hasLeadingZerosInFormat) {\n        maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n      } else {\n        if (sectionConfig.maxLength == null) {\n          throw new Error(`MUI: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\n        }\n        maxLength = sectionConfig.maxLength;\n        if (isValidDate) {\n          sectionValue = cleanLeadingZeros(utils, sectionValue, maxLength);\n        }\n      }\n    }\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      maxLength,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n      hasLeadingZeros: hasLeadingZerosInFormat,\n      hasLeadingZerosInFormat,\n      hasLeadingZerosInInput,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component');\n    }\n  }\n  const expandedFormat = nextFormat;\n\n  // Get start/end indexes of escaped sections\n  const escapedParts = getEscapedPartsFromFormat(utils, expandedFormat);\n\n  // This RegExp test if the beginning of a string correspond to a supported token\n  const isTokenStartRegExp = new RegExp(`^(${Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length) // Sort to put longest word first\n  .join('|')})`, 'g') // used to get access to lastIndex state\n  ;\n\n  let currentTokenValue = '';\n  for (let i = 0; i < expandedFormat.length; i += 1) {\n    const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n    const char = expandedFormat[i];\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const potentialToken = `${currentTokenValue}${expandedFormat.slice(i)}`;\n    const regExpMatch = isTokenStartRegExp.test(potentialToken);\n    if (!isEscapedChar && char.match(/([A-Za-z]+)/) && regExpMatch) {\n      currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);\n      i += isTokenStartRegExp.lastIndex - 1;\n    } else {\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n      if (!isEscapeBoundary) {\n        commitToken(currentTokenValue);\n        currentTokenValue = '';\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n    }\n  }\n  commitToken(currentTokenValue);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = ` ${cleanedSeparator} `;\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input'));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = (sections, isRTL) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRTL) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${dateStr}\\u2069`;\n};\nexport const getSectionsBoundaries = (utils, timezone) => {\n  const today = utils.dateWithTimezone(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8\n};\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' ')) &&\n      // Special case where the spaces were not there in the initial input\n      section.endSeparator !== ' / ';\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};"]},"metadata":{},"sourceType":"module"}