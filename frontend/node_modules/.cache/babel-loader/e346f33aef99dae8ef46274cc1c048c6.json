{"ast":null,"code":"import _slicedToArray from \"/home/brenomatheus/Documentos/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useUtils } from '../useUtils';\nimport { changeSectionValueFormat, cleanDigitSectionValue, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, getDaysInWeekStr, getLetterEditingOptions } from './useField.utils';\n/**\n * The letter editing and the numeric editing each define a `CharacterEditingApplier`.\n * This function decides what the new section value should be and if the focus should switch to the next section.\n *\n * If it returns `null`, then the section value is not updated and the focus does not move.\n */\n\n/**\n * Function called by `applyQuery` which decides:\n * - what is the new section value ?\n * - should the query used to get this value be stored for the next key press ?\n *\n * If it returns `{ sectionValue: string; shouldGoToNextSection: boolean }`,\n * Then we store the query and update the section with the new value.\n *\n * If it returns `{ saveQuery: true` },\n * Then we store the query and don't update the section.\n *\n * If it returns `{ saveQuery: false },\n * Then we do nothing.\n */\n\nvar QUERY_LIFE_DURATION_MS = 5000;\n\nvar isQueryResponseWithoutValue = function isQueryResponseWithoutValue(response) {\n  return response.saveQuery != null;\n};\n/**\n * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).\n * This hook has two main editing behaviors\n *\n * 1. The numeric editing when the user presses a digit\n * 2. The letter editing when the user presses another key\n */\n\n\nexport var useFieldCharacterEditing = function useFieldCharacterEditing(_ref) {\n  var sections = _ref.sections,\n      updateSectionValue = _ref.updateSectionValue,\n      sectionsValueBoundaries = _ref.sectionsValueBoundaries,\n      setTempAndroidValueStr = _ref.setTempAndroidValueStr,\n      timezone = _ref.timezone;\n  var utils = useUtils();\n\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      query = _React$useState2[0],\n      setQuery = _React$useState2[1];\n\n  var resetQuery = useEventCallback(function () {\n    return setQuery(null);\n  });\n  React.useEffect(function () {\n    var _sections$query$secti;\n\n    if (query != null && ((_sections$query$secti = sections[query.sectionIndex]) == null ? void 0 : _sections$query$secti.type) !== query.sectionType) {\n      resetQuery();\n    }\n  }, [sections, query, resetQuery]);\n  React.useEffect(function () {\n    if (query != null) {\n      var timeout = setTimeout(function () {\n        return resetQuery();\n      }, QUERY_LIFE_DURATION_MS);\n      return function () {\n        window.clearTimeout(timeout);\n      };\n    }\n\n    return function () {};\n  }, [query, resetQuery]);\n\n  var applyQuery = function applyQuery(_ref2, getFirstSectionValueMatchingWithQuery, isValidQueryValue) {\n    var keyPressed = _ref2.keyPressed,\n        sectionIndex = _ref2.sectionIndex;\n    var cleanKeyPressed = keyPressed.toLowerCase();\n    var activeSection = sections[sectionIndex]; // The current query targets the section being editing\n    // We can try to concatenated value\n\n    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {\n      var concatenatedQueryValue = \"\".concat(query.value).concat(cleanKeyPressed);\n\n      var _queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);\n\n      if (!isQueryResponseWithoutValue(_queryResponse)) {\n        setQuery({\n          sectionIndex: sectionIndex,\n          value: concatenatedQueryValue,\n          sectionType: activeSection.type\n        });\n        return _queryResponse;\n      }\n    }\n\n    var queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);\n\n    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {\n      resetQuery();\n      return null;\n    }\n\n    setQuery({\n      sectionIndex: sectionIndex,\n      value: cleanKeyPressed,\n      sectionType: activeSection.type\n    });\n\n    if (isQueryResponseWithoutValue(queryResponse)) {\n      return null;\n    }\n\n    return queryResponse;\n  };\n\n  var applyLetterEditing = function applyLetterEditing(params) {\n    var findMatchingOptions = function findMatchingOptions(format, options, queryValue) {\n      var matchingValues = options.filter(function (option) {\n        return option.toLowerCase().startsWith(queryValue);\n      });\n\n      if (matchingValues.length === 0) {\n        return {\n          saveQuery: false\n        };\n      }\n\n      return {\n        sectionValue: matchingValues[0],\n        shouldGoToNextSection: matchingValues.length === 1\n      };\n    };\n\n    var testQueryOnFormatAndFallbackFormat = function testQueryOnFormatAndFallbackFormat(queryValue, activeSection, fallbackFormat, formatFallbackValue) {\n      var getOptions = function getOptions(format) {\n        return getLetterEditingOptions(utils, timezone, activeSection.type, format);\n      };\n\n      if (activeSection.contentType === 'letter') {\n        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);\n      } // When editing a digit-format month / weekDay and the user presses a letter,\n      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.\n      // We just have to make sure that the default month / weekDay format is a letter format,\n\n\n      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {\n        var fallbackOptions = getOptions(fallbackFormat);\n        var response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);\n\n        if (isQueryResponseWithoutValue(response)) {\n          return {\n            saveQuery: false\n          };\n        }\n\n        return _extends({}, response, {\n          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)\n        });\n      }\n\n      return {\n        saveQuery: false\n      };\n    };\n\n    var getFirstSectionValueMatchingWithQuery = function getFirstSectionValueMatchingWithQuery(queryValue, activeSection) {\n      switch (activeSection.type) {\n        case 'month':\n          {\n            var formatFallbackValue = function formatFallbackValue(fallbackValue) {\n              return changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.format);\n            };\n\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, formatFallbackValue);\n          }\n\n        case 'weekDay':\n          {\n            var _formatFallbackValue = function _formatFallbackValue(fallbackValue, fallbackOptions) {\n              return fallbackOptions.indexOf(fallbackValue).toString();\n            };\n\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, _formatFallbackValue);\n          }\n\n        case 'meridiem':\n          {\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);\n          }\n\n        default:\n          {\n            return {\n              saveQuery: false\n            };\n          }\n      }\n    };\n\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery);\n  };\n\n  var applyNumericEditing = function applyNumericEditing(params) {\n    var getNewSectionValue = function getNewSectionValue(queryValue, section) {\n      var queryValueNumber = Number(\"\".concat(queryValue));\n      var sectionBoundaries = sectionsValueBoundaries[section.type]({\n        currentDate: null,\n        format: section.format,\n        contentType: section.contentType\n      });\n\n      if (queryValueNumber > sectionBoundaries.maximum) {\n        return {\n          saveQuery: false\n        };\n      } // If the user types `0` on a month section,\n      // It is below the minimum, but we want to store the `0` in the query,\n      // So that when he pressed `1`, it will store `01` and move to the next section.\n\n\n      if (queryValueNumber < sectionBoundaries.minimum) {\n        return {\n          saveQuery: true\n        };\n      }\n\n      var shouldGoToNextSection = Number(\"\".concat(queryValue, \"0\")) > sectionBoundaries.maximum || queryValue.length === sectionBoundaries.maximum.toString().length;\n      var newSectionValue = cleanDigitSectionValue(utils, timezone, queryValueNumber, sectionBoundaries, section);\n      return {\n        sectionValue: newSectionValue,\n        shouldGoToNextSection: shouldGoToNextSection\n      };\n    };\n\n    var getFirstSectionValueMatchingWithQuery = function getFirstSectionValueMatchingWithQuery(queryValue, activeSection) {\n      if (activeSection.contentType === 'digit' || activeSection.contentType === 'digit-with-letter') {\n        return getNewSectionValue(queryValue, activeSection);\n      } // When editing a letter-format month and the user presses a digit,\n      // We can support the numeric editing by using the digit-format month and re-formatting the result.\n\n\n      if (activeSection.type === 'month') {\n        var hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, 'digit', 'month', 'MM');\n        var response = getNewSectionValue(queryValue, {\n          type: activeSection.type,\n          format: 'MM',\n          hasLeadingZerosInFormat: hasLeadingZerosInFormat,\n          hasLeadingZerosInInput: true,\n          contentType: 'digit',\n          maxLength: 2\n        });\n\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n\n        var formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.format);\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      } // When editing a letter-format weekDay and the user presses a digit,\n      // We can support the numeric editing by returning the nth day in the week day array.\n\n\n      if (activeSection.type === 'weekDay') {\n        var _response = getNewSectionValue(queryValue, activeSection);\n\n        if (isQueryResponseWithoutValue(_response)) {\n          return _response;\n        }\n\n        var _formattedValue = getDaysInWeekStr(utils, timezone, activeSection.format)[Number(_response.sectionValue) - 1];\n        return _extends({}, _response, {\n          sectionValue: _formattedValue\n        });\n      }\n\n      return {\n        saveQuery: false\n      };\n    };\n\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery, function (queryValue) {\n      return !Number.isNaN(Number(queryValue));\n    });\n  };\n\n  var applyCharacterEditing = useEventCallback(function (params) {\n    var activeSection = sections[params.sectionIndex];\n    var isNumericEditing = !Number.isNaN(Number(params.keyPressed));\n    var response = isNumericEditing ? applyNumericEditing(params) : applyLetterEditing(params);\n\n    if (response == null) {\n      setTempAndroidValueStr(null);\n    } else {\n      updateSectionValue({\n        activeSection: activeSection,\n        newSectionValue: response.sectionValue,\n        shouldGoToNextSection: response.shouldGoToNextSection\n      });\n    }\n  });\n  return {\n    applyCharacterEditing: applyCharacterEditing,\n    resetCharacterQuery: resetQuery\n  };\n};","map":{"version":3,"sources":["/home/brenomatheus/Documentos/frontend/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldCharacterEditing.js"],"names":["_extends","React","useEventCallback","useUtils","changeSectionValueFormat","cleanDigitSectionValue","doesSectionFormatHaveLeadingZeros","getDateSectionConfigFromFormatToken","getDaysInWeekStr","getLetterEditingOptions","QUERY_LIFE_DURATION_MS","isQueryResponseWithoutValue","response","saveQuery","useFieldCharacterEditing","sections","updateSectionValue","sectionsValueBoundaries","setTempAndroidValueStr","timezone","utils","useState","query","setQuery","resetQuery","useEffect","_sections$query$secti","sectionIndex","type","sectionType","timeout","setTimeout","window","clearTimeout","applyQuery","getFirstSectionValueMatchingWithQuery","isValidQueryValue","keyPressed","cleanKeyPressed","toLowerCase","activeSection","value","concatenatedQueryValue","queryResponse","applyLetterEditing","params","findMatchingOptions","format","options","queryValue","matchingValues","filter","option","startsWith","length","sectionValue","shouldGoToNextSection","testQueryOnFormatAndFallbackFormat","fallbackFormat","formatFallbackValue","getOptions","contentType","fallbackOptions","fallbackValue","formats","month","indexOf","toString","weekday","applyNumericEditing","getNewSectionValue","section","queryValueNumber","Number","sectionBoundaries","currentDate","maximum","minimum","newSectionValue","hasLeadingZerosInFormat","hasLeadingZerosInInput","maxLength","formattedValue","isNaN","applyCharacterEditing","isNumericEditing","resetCharacterQuery"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { useUtils } from '../useUtils';\nimport { changeSectionValueFormat, cleanDigitSectionValue, doesSectionFormatHaveLeadingZeros, getDateSectionConfigFromFormatToken, getDaysInWeekStr, getLetterEditingOptions } from './useField.utils';\n\n/**\n * The letter editing and the numeric editing each define a `CharacterEditingApplier`.\n * This function decides what the new section value should be and if the focus should switch to the next section.\n *\n * If it returns `null`, then the section value is not updated and the focus does not move.\n */\n\n/**\n * Function called by `applyQuery` which decides:\n * - what is the new section value ?\n * - should the query used to get this value be stored for the next key press ?\n *\n * If it returns `{ sectionValue: string; shouldGoToNextSection: boolean }`,\n * Then we store the query and update the section with the new value.\n *\n * If it returns `{ saveQuery: true` },\n * Then we store the query and don't update the section.\n *\n * If it returns `{ saveQuery: false },\n * Then we do nothing.\n */\n\nconst QUERY_LIFE_DURATION_MS = 5000;\nconst isQueryResponseWithoutValue = response => response.saveQuery != null;\n\n/**\n * Update the active section value when the user pressed a key that is not a navigation key (arrow key for example).\n * This hook has two main editing behaviors\n *\n * 1. The numeric editing when the user presses a digit\n * 2. The letter editing when the user presses another key\n */\nexport const useFieldCharacterEditing = ({\n  sections,\n  updateSectionValue,\n  sectionsValueBoundaries,\n  setTempAndroidValueStr,\n  timezone\n}) => {\n  const utils = useUtils();\n  const [query, setQuery] = React.useState(null);\n  const resetQuery = useEventCallback(() => setQuery(null));\n  React.useEffect(() => {\n    var _sections$query$secti;\n    if (query != null && ((_sections$query$secti = sections[query.sectionIndex]) == null ? void 0 : _sections$query$secti.type) !== query.sectionType) {\n      resetQuery();\n    }\n  }, [sections, query, resetQuery]);\n  React.useEffect(() => {\n    if (query != null) {\n      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);\n      return () => {\n        window.clearTimeout(timeout);\n      };\n    }\n    return () => {};\n  }, [query, resetQuery]);\n  const applyQuery = ({\n    keyPressed,\n    sectionIndex\n  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {\n    const cleanKeyPressed = keyPressed.toLowerCase();\n    const activeSection = sections[sectionIndex];\n\n    // The current query targets the section being editing\n    // We can try to concatenated value\n    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {\n      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;\n      const queryResponse = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);\n      if (!isQueryResponseWithoutValue(queryResponse)) {\n        setQuery({\n          sectionIndex,\n          value: concatenatedQueryValue,\n          sectionType: activeSection.type\n        });\n        return queryResponse;\n      }\n    }\n    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);\n    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {\n      resetQuery();\n      return null;\n    }\n    setQuery({\n      sectionIndex,\n      value: cleanKeyPressed,\n      sectionType: activeSection.type\n    });\n    if (isQueryResponseWithoutValue(queryResponse)) {\n      return null;\n    }\n    return queryResponse;\n  };\n  const applyLetterEditing = params => {\n    const findMatchingOptions = (format, options, queryValue) => {\n      const matchingValues = options.filter(option => option.toLowerCase().startsWith(queryValue));\n      if (matchingValues.length === 0) {\n        return {\n          saveQuery: false\n        };\n      }\n      return {\n        sectionValue: matchingValues[0],\n        shouldGoToNextSection: matchingValues.length === 1\n      };\n    };\n    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {\n      const getOptions = format => getLetterEditingOptions(utils, timezone, activeSection.type, format);\n      if (activeSection.contentType === 'letter') {\n        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);\n      }\n\n      // When editing a digit-format month / weekDay and the user presses a letter,\n      // We can support the letter editing by using the letter-format month / weekDay and re-formatting the result.\n      // We just have to make sure that the default month / weekDay format is a letter format,\n      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils, fallbackFormat).contentType === 'letter') {\n        const fallbackOptions = getOptions(fallbackFormat);\n        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);\n        if (isQueryResponseWithoutValue(response)) {\n          return {\n            saveQuery: false\n          };\n        }\n        return _extends({}, response, {\n          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)\n        });\n      }\n      return {\n        saveQuery: false\n      };\n    };\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      switch (activeSection.type) {\n        case 'month':\n          {\n            const formatFallbackValue = fallbackValue => changeSectionValueFormat(utils, fallbackValue, utils.formats.month, activeSection.format);\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.month, formatFallbackValue);\n          }\n        case 'weekDay':\n          {\n            const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils.formats.weekday, formatFallbackValue);\n          }\n        case 'meridiem':\n          {\n            return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);\n          }\n        default:\n          {\n            return {\n              saveQuery: false\n            };\n          }\n      }\n    };\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery);\n  };\n  const applyNumericEditing = params => {\n    const getNewSectionValue = (queryValue, section) => {\n      const queryValueNumber = Number(`${queryValue}`);\n      const sectionBoundaries = sectionsValueBoundaries[section.type]({\n        currentDate: null,\n        format: section.format,\n        contentType: section.contentType\n      });\n      if (queryValueNumber > sectionBoundaries.maximum) {\n        return {\n          saveQuery: false\n        };\n      }\n\n      // If the user types `0` on a month section,\n      // It is below the minimum, but we want to store the `0` in the query,\n      // So that when he pressed `1`, it will store `01` and move to the next section.\n      if (queryValueNumber < sectionBoundaries.minimum) {\n        return {\n          saveQuery: true\n        };\n      }\n      const shouldGoToNextSection = Number(`${queryValue}0`) > sectionBoundaries.maximum || queryValue.length === sectionBoundaries.maximum.toString().length;\n      const newSectionValue = cleanDigitSectionValue(utils, timezone, queryValueNumber, sectionBoundaries, section);\n      return {\n        sectionValue: newSectionValue,\n        shouldGoToNextSection\n      };\n    };\n    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {\n      if (activeSection.contentType === 'digit' || activeSection.contentType === 'digit-with-letter') {\n        return getNewSectionValue(queryValue, activeSection);\n      }\n\n      // When editing a letter-format month and the user presses a digit,\n      // We can support the numeric editing by using the digit-format month and re-formatting the result.\n      if (activeSection.type === 'month') {\n        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, 'digit', 'month', 'MM');\n        const response = getNewSectionValue(queryValue, {\n          type: activeSection.type,\n          format: 'MM',\n          hasLeadingZerosInFormat,\n          hasLeadingZerosInInput: true,\n          contentType: 'digit',\n          maxLength: 2\n        });\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n        const formattedValue = changeSectionValueFormat(utils, response.sectionValue, 'MM', activeSection.format);\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      }\n\n      // When editing a letter-format weekDay and the user presses a digit,\n      // We can support the numeric editing by returning the nth day in the week day array.\n      if (activeSection.type === 'weekDay') {\n        const response = getNewSectionValue(queryValue, activeSection);\n        if (isQueryResponseWithoutValue(response)) {\n          return response;\n        }\n        const formattedValue = getDaysInWeekStr(utils, timezone, activeSection.format)[Number(response.sectionValue) - 1];\n        return _extends({}, response, {\n          sectionValue: formattedValue\n        });\n      }\n      return {\n        saveQuery: false\n      };\n    };\n    return applyQuery(params, getFirstSectionValueMatchingWithQuery, queryValue => !Number.isNaN(Number(queryValue)));\n  };\n  const applyCharacterEditing = useEventCallback(params => {\n    const activeSection = sections[params.sectionIndex];\n    const isNumericEditing = !Number.isNaN(Number(params.keyPressed));\n    const response = isNumericEditing ? applyNumericEditing(params) : applyLetterEditing(params);\n    if (response == null) {\n      setTempAndroidValueStr(null);\n    } else {\n      updateSectionValue({\n        activeSection,\n        newSectionValue: response.sectionValue,\n        shouldGoToNextSection: response.shouldGoToNextSection\n      });\n    }\n  });\n  return {\n    applyCharacterEditing,\n    resetCharacterQuery: resetQuery\n  };\n};"]},"metadata":{},"sourceType":"module"}